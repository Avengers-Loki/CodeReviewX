name: Clean Up Stale Branches

on:
  schedule:
    # Run weekly on Sunday at 00:00 UTC
    - cron: '0 0 * * 0'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Perform a dry run (list branches without deleting)'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  cleanup-branches:
    name: Clean Up Stale Branches
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Clean Up Stale Branches
        uses: actions/github-script@v7
        with:
          script: |
            // Configuration
            const MAX_BRANCHES_TO_PROCESS = 500; // Safety limit to prevent excessive processing
            
            // For scheduled runs, always use dry run mode for safety
            // For manual runs, respect the input parameter (default is 'true')
            const isScheduled = github.event_name === 'schedule';
            const dryRunInput = '${{ github.event.inputs.dry_run }}' || 'true';
            const dryRun = isScheduled || dryRunInput === 'true';
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const protectedBranches = ['main', 'master'];
            
            console.log(`Running in ${dryRun ? 'DRY RUN' : 'LIVE'} mode`);
            
            try {
              // Get all branches (with pagination support)
              const branches = [];
              let page = 1;
              const perPage = 100;
              let hasMore = true;
              
              while (hasMore && branches.length < MAX_BRANCHES_TO_PROCESS) {
                const { data: branchPage } = await github.rest.repos.listBranches({
                  owner: owner,
                  repo: repo,
                  per_page: perPage,
                  page: page
                });
                
                branches.push(...branchPage);
                hasMore = branchPage.length === perPage;
                page++;
              }
              
              console.log(`Found ${branches.length} branches`);
              
              // Get default branch
              const { data: repoData } = await github.rest.repos.get({
                owner: owner,
                repo: repo
              });
              
              const defaultBranch = repoData.default_branch;
              console.log(`Default branch: ${defaultBranch}`);
              
              let deletedCount = 0;
              let skippedCount = 0;
              let errorCount = 0;
              
              // Note: For repositories with many branches (100+), consider implementing
              // batch processing or pagination to avoid rate limits
              
              for (const branch of branches) {
                const branchName = branch.name;
                
                // Skip protected branches and default branch
                if (protectedBranches.includes(branchName) || branchName === defaultBranch) {
                  console.log(`â­ï¸  Skipping protected branch: ${branchName}`);
                  skippedCount++;
                  continue;
                }
                
                try {
                  // Check if branch should be deleted
                  // A branch is safe to delete if:
                  // 1. It has no commits ahead of the default branch (ahead_by === 0)
                  // 2. This means all its commits are already in the default branch (merged)
                  let shouldDelete = false;
                  try {
                    const comparison = await github.rest.repos.compareCommitsWithBasehead({
                      owner: owner,
                      repo: repo,
                      basehead: `${defaultBranch}...${branchName}`
                    });
                    // Branch is safe to delete if it has no unique commits
                    shouldDelete = comparison.data.ahead_by === 0;
                    
                    if (shouldDelete) {
                      console.log(`âœ“ Branch ${branchName} has no unique commits (ahead_by: ${comparison.data.ahead_by}, behind_by: ${comparison.data.behind_by})`);
                    }
                  } catch (compareError) {
                    console.log(`âš ï¸  Could not compare branch ${branchName}: ${compareError.message}`);
                  }
                  
                  if (shouldDelete) {
                    if (dryRun) {
                      console.log(`ðŸ” [DRY RUN] Would delete branch: ${branchName}`);
                    } else {
                      await github.rest.git.deleteRef({
                        owner: owner,
                        repo: repo,
                        ref: `heads/${branchName}`
                      });
                      console.log(`âœ… Deleted branch: ${branchName}`);
                      deletedCount++;
                    }
                  } else {
                    console.log(`â­ï¸  Skipping branch with unique commits: ${branchName}`);
                    skippedCount++;
                  }
                } catch (error) {
                  if (error.status === 422 || error.status === 404) {
                    console.log(`âš ï¸  Branch ${branchName} already deleted or not found`);
                  } else {
                    console.error(`âŒ Error processing branch ${branchName}: ${error.message}`);
                    errorCount++;
                  }
                }
              }
              
              console.log('\nðŸ“Š Summary:');
              console.log(`   Deleted: ${deletedCount}`);
              console.log(`   Skipped: ${skippedCount}`);
              console.log(`   Errors: ${errorCount}`);
              
              if (dryRun) {
                console.log('\nâ„¹ï¸  This was a dry run. No branches were actually deleted.');
                console.log('   To delete branches, run this workflow manually with dry_run=false');
              }
            } catch (error) {
              console.error('Fatal error:', error);
              // Don't fail the workflow, just log the error
              console.log('Workflow completed with errors but will not fail');
            }